package Gene.algos;

import Gene.utils.Aligner;

import java.util.*;

/**
 * @Author: HUANG SHENYUAN
 * @Date: 4/28/2019 12:47 PM
 * @Algo: The population is generated by a random algorithm using a simple genetic algorithm.
 * Some definitions -
 * Crossover: We randomly selected two genes, truncated from the middle, recombined, and generated two new genes.
 * Fitness: We use the dynamic programming alignment method to calculate fitness.
 * Mutation: Small probabilities appear to mutate when copied.
 * Selection: All sequences above average
 */
public class GeneticGeneMaker implements GeneMaker {
    private static final int POPULATION = 10000;
    private static final double RATE_MUTATION = 0.1;
    private static final int MAX_GENERATION = 100;
    private static final int NUMBER_THREAD = Runtime.getRuntime().availableProcessors();
    private LinkedList<Sequence> populations = new LinkedList<>();
    private Vector<Sequence> pop_crossover = new Vector<>();
    private Vector<Sequence> pop_newGeneration = new Vector<>();
    private Random random = new Random();
    private char[] target;
    private int currentPopulation = 0;

    private class Fragment {
        char[] seq;

        Fragment(String lib) {
            this.seq = lib.toCharArray();
        }

        char[] getSeq() {
            return seq;
        }

        int length() {
            return seq.length;
        }

        @Override
        public String toString() {
            return String.valueOf(seq);
        }
    }

    private class Sequence {
        private List<Fragment> seq = new ArrayList<>();
        private int length = 0;
        private Random random = new Random();
        private int score = 0;

        void addFgt(Fragment fragment) {
            seq.add(fragment);
            length += fragment.length();
        }

        void mutation() {
            int old = random.nextInt(seq.size());
            Fragment newFgt = lib[random.nextInt(lib.length)];
            length = length - seq.get(old).length() + newFgt.length();
            seq.set(old, newFgt);
        }

        int length() {
            return this.length;
        }

        Sequence[] getHalf() {
            Sequence[] halfSeq = new Sequence[2];
            Sequence front = new Sequence();
            Sequence back = new Sequence();
            int half = length / 2;
            int offsetOld;
            int index = 0;
            while (front.length() < half) {
                offsetOld = Math.abs(half - front.length);
                Fragment fragment = seq.get(index++);
                int offset = half - front.length - fragment.length();
                if (offset < 0) {
                    if (offsetOld < offset) {
                        index--;
                        break;
                    }
                }
                front.addFgt(fragment);
            }
            for (int i = index; i < seq.size(); i++) {
                back.addFgt(seq.get(i));
            }
            halfSeq[0] = front;
            halfSeq[1] = back;
            return halfSeq;
        }

        Sequence add(Sequence back) {
            seq.addAll(back.seq);
            this.updateScore();
            return this;
        }

        char[] toCharList() {
            StringBuilder builder = new StringBuilder();
            for (int i = 0; i < seq.size(); i++) {
                builder.append(String.valueOf(seq.get(i).getSeq()));
            }
            return builder.toString().toCharArray();
        }

        void updateScore() {
            this.score = new Aligner(target, this.toCharList()).getAlignScore();
        }

        int getScore() {
            return this.score;
        }
    }

    private Fragment[] lib;

    public GeneticGeneMaker(String[] lib) {
        this.lib = new Fragment[lib.length];
        for (int i = 0; i < lib.length; i++)
            this.lib[i] = new Fragment(lib[i]);
    }

    @Override
    public char[] produce(char[] target) {
        this.target = target;
        for (int i = 0; i < POPULATION; i++) {
            Sequence seq = new Sequence();
            while (seq.length() < target.length) {
                seq.addFgt(lib[random.nextInt(lib.length)]);
            }
            seq.updateScore();
            populations.add(seq);
        }
        System.out.println("Initial Complete");
        for (int i = 0; i < MAX_GENERATION; i++) {
//            System.out.println("Generation :" + i);
            selection();
//            System.out.println("Selection Complete");
            currentPopulation = populations.size();
            pop_crossover.clear();
            pop_newGeneration.clear();
            pop_crossover.addAll(populations);//Vector is multi-thread safe
            Thread[] threads = new Thread[NUMBER_THREAD];
            for(int z = 0 ;z<NUMBER_THREAD;z++){
                threads[z] = new Thread(new CrossOver());
                threads[z].start();
            }
//            System.out.println(NUMBER_THREAD + "Threads CrossOver Started");
            for(int z = 0 ;z<NUMBER_THREAD;z++){
                try {
                    threads[z].join();
                }catch (InterruptedException ie){
                    ie.printStackTrace();
                }
            }
//            System.out.println(NUMBER_THREAD + "Threads CrossOver finished");

            populations.addAll(pop_newGeneration);
//            System.out.println("Crossover Complete");
        }
        return best();
    }

    private char[] best() {
        int best = -999999999;
        Sequence bestSeq = populations.getFirst();
        for (Sequence s : populations) {
            if (s.getScore() > best) {
                bestSeq = s;
                best = s.getScore();
            }
        }
        return bestSeq.toCharList();
    }

    private void mutation(Sequence sequence) {
        if (random.nextInt(99) < 100 * RATE_MUTATION) {
            sequence.mutation();
            sequence.updateScore();
        }
    }


    private void selection() {
        int average;
        int total = 0;
        for (Sequence s : populations) {
            total += s.getScore();
        }
        average = total / populations.size();

        Iterator<Sequence> it = populations.iterator();
        while (it.hasNext()) {
            Sequence x = it.next();
            if (x.getScore() < average) {
                it.remove();
            }
        }
    }

    class CrossOver implements Runnable{
        @Override
        public void run() {
            while (currentPopulation + pop_newGeneration.size() < POPULATION) {
                Sequence a = pop_crossover.get(random.nextInt(pop_crossover.size()));
                Sequence b = pop_crossover.get(random.nextInt(pop_crossover.size()));
                Sequence[] ah = a.getHalf();
                Sequence[] bh = b.getHalf();
                Sequence aNew = ah[0].add(bh[1]);
                Sequence bNew = bh[0].add(ah[1]);
                mutation(aNew);
                mutation(bNew);
                pop_newGeneration.add(aNew);
                pop_newGeneration.add(bNew);
            }
        }
    }
}
